/**
This file contains the GTK-specific parts of Plot2Kill and is publicly
imported by plot2kill.figure if compiled with -version=gtk.

Note:  The functions that need GTK to be initialized for their use automatically
       call gtk.Main.initCheck() to provide sane default initialization.  This
       is for convenience in programs that throw up a few simple plots and
       otherwise don't have a GUI.  If gtk.Main.init() is called before
       calling any function in this module that requires GTK to be initialized,
       the first call's settings take precedence and the calls from this
       module have no effect.

Copyright (C) 2010-2011 David Simcha

License:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */
module plot2kill.gtkwrapper;

version(gtk) {

import plot2kill.util;
import plot2kill.guiagnosticbase;
import plot2kill.subplot;
import plot2kill.figure;

import gdk.Color, gdk.GC, gtk.Widget, gdk.Drawable, gtk.DrawingArea,
    gtk.MainWindow, gtk.Main, gdk.Window, gtk.Container, gtk.Window,
    gdk.Pixbuf, gdk.Pixmap, gtkc.all, gtk.FileChooserDialog, gtk.Dialog,
    gtk.FileFilter, gobject.ObjectG, cairo.Context, cairo.FontFace,
    gtkc.cairotypes, cairo.PdfSurface, cairo.SvgSurface,
    cairo.PostScriptSurface, cairo.Surface, cairo.ImageSurface,
    gtk.FileSelection, gtk.MessageDialog, gtk.Menu, gtk.MenuItem,
    gtk.Entry, gtk.HBox, gtk.Label, gtk.FontSelectionDialog;

// Default initialize GTK.
package void defaultInit() {
    string[] args;
    Main.initCheck(args);
}

/**GTK's implementation of a color object.*/
struct Color {
    ubyte r;
    ubyte g;
    ubyte b;
}

/**Holds context for drawing lines.*/
struct Pen {
    Color color;
    double lineWidth;
}

/**Holds context for drawing rectangles.*/
struct Brush {
    Color color;
}

///
struct Point {
    ///
    int x;

    ///
    int y;
}

///
struct Rect {
    ///
    int x;

    ///
    int y;

    ///
    int width;

    ///
    int height;
}

///
struct Size {
    ///
    int width;

    ///
    int height;
}

/**Holds font information.*/
alias cairo.FontFace.FontFace font;

/**Get a color in a GUI framework-agnostic way.*/
Color getColor(ubyte red, ubyte green, ubyte blue) {
    return Color(red, green, blue);
}

/**Get a font in a GUI framework-agnostic way.*/
struct Font {
    FontFace face;
    string name;
    double size;
}

Font getFont(string fontName, double size) {
    return Font(
        Context.toyFontFaceCreate(
            fontName,
            cairo_font_slant_t.NORMAL,
            cairo_font_weight_t.NORMAL
        ), fontName, size
    );
}


///
enum TextAlignment {
    ///
    Left = 0,

    ///
    Center = 1,

    ///
    Right = 2
}

// This calls the relevant lib's method of cleaning up the given object, if
// any.
void doneWith(T)(T garbage) {
    static if(is(T : gdk.GC.GC) || is(T : gdk.Pixmap.Pixmap) ||
              is(T : gdk.Pixbuf.Pixbuf)) {
        // Most things seem to manage themselves fine, but these objects
        // leak like a seive.
        garbage.unref();

        // Since we're already in here be dragons territory, we may as well:
        core.memory.GC.free(cast(void*) garbage);
    } else static if(is(T : cairo.Context.Context) || is(T : cairo.Surface.Surface)) {

        static if(is(T : cairo.Surface.Surface)) {
            garbage.finish();
        }
        garbage.destroy();
    }
}

/**The base class for both FigureBase and Subplot.  Holds common functionality
 * like saving and text drawing.
 */
abstract class FigureBase : GuiAgnosticBase {
private:
    enum ubyteMax = cast(double) ubyte.max;

    // See drawLine() for an explanation of these variables.
    PlotPoint[2] lastLine;
    Pen lastLinePen;

    void saveImplPixmap
    (string filename, string type, double width, double height) {
        defaultInit();
        int w = roundTo!int(width);
        int h = roundTo!int(height);

        auto pixmap = new Pixmap(null, w, h, 24);
        scope(exit) doneWith(pixmap);

        auto c = new Context(pixmap);
        scope(exit) doneWith(c);

        this.drawTo(c, PlotRect(0, 0, w, h));
        auto pixbuf = new Pixbuf(pixmap, 0, 0, w, h);
        scope(exit) doneWith(pixbuf);

        int result = pixbuf.savev(filename, type, null, null);
        enforce(result, "File not saved successfully.");
    }

    void saveImplSurface
    (string filename, string type, double width, double height) {
        Surface surf;
        switch(type) {
            case "pdf":
                surf = PdfSurface.create(filename, width, height);
                break;
            case "eps":
                surf = PostScriptSurface.create(filename, width, height);
                break;
            case "svg":
                surf = SvgSurface.create(filename, width, height);
                break;
            case "png":
                surf = ImageSurface.create(cairo_format_t.RGB24,
                    roundTo!int(width), roundTo!int(height));
                break;
            default:
                enforce(0, "Invalid file format:  " ~ type);
        }

        enforce(surf, "Couldn't save file because surface couldn't be created.");

        scope(exit) doneWith(surf);
        auto context = Context.create(surf);
        scope(exit) doneWith(context);

        this.drawTo(context, PlotRect(0,0, width, height));
        surf.flush();

        if(type == "png") {
            // So sue me for the cast.
            auto result = (cast(ImageSurface) surf).writeToPng(filename);
            enforce(result == cairo_status_t.SUCCESS, text(
                "Unsuccessfully wrote png.  Error:  ", result));
        }

    }

protected:
    // Fonts tend to be different actual sizes on different GUI libs for a
    // given nominal size. This adjusts for that factor when setting default
    // fonts.
    enum fontSizeAdjust = 0;

    Context context;

public:
    // These are undocumented FOR A REASON:  They aren't part of the public
    // API, but package is so broken it's not usable.  All this stuff w/o
    // ddoc should only be messed with if you're a developer of this lib,
    // not if you want to use it as a black box.

    final void drawLine
    (Pen pen, double startX, double startY, double endX, double endY) {
        /* HACK ALERT:  The front end to this library is designed for each line
         * to be drawn as a discrete unit, but for line joining purposes,
         * lines need to be drawn in a single path in Cairo.  Therefore,
         * we save the last line drawn and draw it again if its end coincides
         * with the current line's beginning.
         */
        context.save();
        scope(exit) context.restore();
        context.newPath();

        auto c = pen.color;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);
        context.setLineWidth(pen.lineWidth);

        if(lastLine[1] == PlotPoint(startX, startY) && lastLinePen == pen) {
            // Redraw the last line.
            context.moveTo(lastLine[0].x + xOffset, lastLine[0].y + yOffset);
            context.lineTo(lastLine[1].x + xOffset, lastLine[1].y + yOffset);
        } else {
            context.moveTo(startX + xOffset, startY + yOffset);
        }

        lastLine[0] = PlotPoint(startX, startY);
        lastLine[1] = PlotPoint(endX, endY);
        lastLinePen = pen;

        context.lineTo(endX + xOffset, endY + yOffset);
        context.stroke();
    }

    final void drawLine(Pen pen, PlotPoint start, PlotPoint end) {
        this.drawLine(pen, start.x, start.y, end.x, end.y);
    }

    final void drawRectangle
    (Pen pen, double x, double y, double width, double height) {
        context.save();
        scope(exit) context.restore();
        context.newPath();

        auto c = pen.color;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);
        context.setLineWidth(pen.lineWidth);
        context.rectangle(x + xOffset, y + yOffset, width, height);
        context.stroke();
    }

    final void drawRectangle(Pen pen, Rect r) {
        this.drawRectangle(pen, r.x, r.y, width, height);
    }

    final void fillRectangle
    (Brush brush, double x, double y, double width, double height) {
        context.save();
        scope(exit) context.restore();
        context.newPath();

        auto c = brush.color;
        enum ubyteMax = cast(double) ubyte.max;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);
        context.rectangle(x + xOffset, y + yOffset, width, height);
        context.fill();
    }

    final void fillRectangle(Brush brush, Rect r) {
        this.fillRectangle(brush, r.x, r.y, r.width, r.height);
    }

    final void drawText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect,
        TextAlignment alignment
    ) {
        context.save();
        scope(exit) context.restore();
        context.newPath();

        drawTextCurrentContext(text, font, pointColor, rect, alignment);
    }

    final void drawTextCurrentContext(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect,
        TextAlignment alignment
    ) {
        alias rect r;  // save typing
        auto measurements = measureText(text, font);
        if(measurements.width > rect.width) {
            alignment = TextAlignment.Left;
        }

        if(alignment == TextAlignment.Left) {
            r = PlotRect(
                r.x,
                r.y + measurements.height,
                r.width,
                r.height
            );
        } else if(alignment == TextAlignment.Center) {
            r = PlotRect(
                r.x + (r.width - measurements.width) / 2,
                r.y + measurements.height,
                r.width, r.height
            );
        } else if(alignment == TextAlignment.Right) {
            r = PlotRect(
                r.x + (r.width - measurements.width),
                r.y + measurements.height,
                r.width, r.height
            );
        } else {
            assert(0);
        }

        //context.rectangle(r.x, r.y - measurements.height, r.width, r.height);
        //context.clip();
        context.setFontSize(font.size);
        context.setFontFace(font.face);

        alias pointColor c;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);

        context.setLineWidth(0.5);
        context.moveTo(r.x + xOffset, r.y + yOffset);
        context.textPath(text);
        context.fill();
    }

    final void drawText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect
    ) {
        drawText(text, font, pointColor, rect, TextAlignment.Left);
    }

    final void drawRotatedText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect,
        TextAlignment alignment
    ) {
        context.save();
        scope(exit) context.restore;
        context.newPath();

        alias rect r;  // save typing
        auto measurements = measureText(text, font);
        immutable slack  = rect.height - measurements.width;
        if(slack < 0) {
            alignment = TextAlignment.Left;
        }

        if(alignment == TextAlignment.Left) {
            r = PlotRect(
                r.x + r.width,
                r.y + r.height,
                r.width,
                r.height
            );
        } else if(alignment == TextAlignment.Center) {
            r = PlotRect(
                r.x + r.width,
                r.y + r.height - slack / 2,
                r.width, r.height
            );
        } else if(alignment == TextAlignment.Right) {
            r = PlotRect(
                r.x + r.width,
                r.y + r.height - slack,
                r.width, r.height
            );
        } else {
            assert(0);
        }
        //context.rectangle(r.x, r.y - measurements.height, r.width, r.height);
        //context.clip();
        context.setFontSize(font.size);
        context.setFontFace(font.face);

        alias pointColor c;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);

        context.setLineWidth(0.5);
        context.moveTo(r.x + xOffset, r.y + yOffset);
        context.rotate(PI * 1.5);
        context.textPath(text);
        context.fill();
    }

    final void drawRotatedText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect
    ) {
        drawRotatedText(text, font, pointColor, rect, TextAlignment.Left);
    }

    // BUGS:  Ignores maxWidth.
    final PlotSize measureText
    (string text, Font font, double maxWidth, TextAlignment alignment) {
        return measureText(text, font);
    }

    // BUGS:  Ignores maxWidth.
    final PlotSize measureText(string text, Font font, double maxWidth) {
        return measureText(text, font);

    }

    final PlotSize measureText(string text, Font font) {
        context.save();
        scope(exit) context.restore();

        context.setLineWidth(1);
        context.setFontSize(font.size);
        context.setFontFace(font.face);
        cairo_text_extents_t ext;

        context.textExtents(text, &ext);
        return PlotSize(ext.width, ext.height);
    }

    // TODO:  Add support for stuff other than solid brushes.
    /*Get a brush in a GUI framework-agnostic way.*/
    static Brush getBrush(Color color) {
        return Brush(color);
    }

    /*Get a pen in a GUI framework-agnostic way.*/
    static Pen getPen(Color color, double width = 1) {
        return Pen(color, width);
    }

    void drawTo(Context context) {
        drawTo(context, this.width, this.height);
    }

    void drawTo(Context context, double width, double height) {
        return drawTo(context, PlotRect(0, 0, width, height));
    }

    // Allows drawing at an offset from the origin.
    void drawTo(Context context, PlotRect whereToDraw) {
        enforceSane(whereToDraw);
        // Save the default class-level values, make the values passed in the
        // class-level values, call drawImpl(), then restore the default values.
        auto oldContext = this.context;
        auto oldWidth = this._width;
        auto oldHeight = this._height;
        auto oldXoffset = this.xOffset;
        auto oldYoffset = this.yOffset;

        scope(exit) {
            this.context = oldContext;
            this._height = oldHeight;
            this._width = oldWidth;
            this.xOffset = oldXoffset;
            this.yOffset = oldYoffset;
        }

        this.context = context;
        this._width = whereToDraw.width;
        this._height = whereToDraw.height;
        this.xOffset = whereToDraw.x;
        this.yOffset = whereToDraw.y;
        drawImpl();
    }

    /**Saves this figure to a file.  The file type can be one of either the
     * raster formats .png, .jpg, .tiff, and .bmp, or the vector formats
     * .pdf, .svg and .eps.  The width and height parameters allow you to
     * specify explicit width and height parameters for the image file.  If
     * width and height are left at their default values
     * of 0, the default width and height of the subclass being saved will
     * be used.
     *
     * Bugs:  .jpg, .tiff and .bmp formats rely on Pixmap objects, meaning
     *        you can't save them to a file unless you have a screen and
     *        have called Main.init(), even though saving should have
     *        nothing to do with X or screens.
     */
    void saveToFile
    (string filename, string type, double width = 0, double height = 0) {
        // User friendliness:  Remove . if it was included, don't be case sens.
        type = tolower(type);
        if(!type.empty && type.front == '.') {
            type.popFront();
        }
        if(type == "jpg") {
            type = "jpeg";
        }

        if(width == 0 || height == 0) {
            width = this.defaultWindowWidth;
            height = this.defaultWindowHeight;
        }

        if(type == "eps" || type == "pdf" || type == "svg" || type == "png") {
            return saveImplSurface(filename, type, width, height);
        } else {
            enforce(type == "tiff" || type == "bmp" || type == "jpeg",
                "Invalid format:  " ~ type);
            return saveImplPixmap(filename, type, width, height);
        }
    }

    /**Convenience function that infers the type from the filename extenstion
     * and defaults to .png if no valid file format extension is found.
     */
    void saveToFile(string filename, double width = 0, double height = 0) {
        auto type = tolower(getExt(filename));

        try {
            saveToFile(filename, type, width, height);
        } catch {
            // Default to png.
            saveToFile(filename, "png", width, height);
        }
    }

    /**Creates a Widget that will have this object drawn to it.  This Widget
     * can be displayed in a window.
     */
    FigureWidget toWidget() {
        defaultInit();
        return new FigureWidget(this);
    }

    /**Draw and display the figure as a main form.  This is useful in
     * otherwise console-based apps that want to display a few plots.
     * However, you can't have another main form up at the same time.
     */
    void showAsMain() {
        auto mw = new DefaultPlotWindow!(MainWindow)(this.toWidget);
        Main.run();
    }

    /**Returns a default plot window with this figure in it.*/
    gtk.Window.Window getDefaultWindow() {
        return new DefaultPlotWindow!(gtk.Window.Window)(this.toWidget);
    }
}


/**The default widget for displaying Figure and Subplot objects on screen.
 * This class has no public constructor or static factory method because the
 * proper way to instantiate this object is via the toWidget properties
 * of FigureBase and Subplot.
 */
class FigureWidget : DrawingArea {
private:
    FigureBase _figure;

package:
    this(FigureBase fig) {
        super();
        this._figure = fig;
        this.addOnExpose(&onDrawingExpose);
        this.setSizeRequest(fig.minWindowWidth, fig.minWindowHeight);
    }

    bool onDrawingExpose(GdkEventExpose* event, Widget drawingArea) {
        draw();
        return true;
    }

    void draw(double w, double h) {
        enforce(getParent() !is null, this.classinfo.name);
        auto context = new Context(getWindow());
        scope(exit) doneWith(context);

        figure.drawTo(context, w, h);
    }

public:
    /**Get the underlying FigureBase object.*/
    final FigureBase figure() @property {
        return _figure;
    }

    /**If set as an addOnSizeAllocate callback, this will resize this control
     * to the size of its parent window when the parent window is resized.
     */
    void parentSizeChanged(GtkAllocation* alloc, Widget widget) {
        if(this.getWidth != alloc.width || this.getHeight != alloc.height) {
            this.setSizeRequest(alloc.width, alloc.height);
        }
    }

    /**Draw the figure to the internal drawing area.*/
    final void draw() {
        draw(this.getWidth, this.getHeight);
    }

}

// Convenience subclass of Dialog that has the entries for title, xlabel
// and ylabel available in a way that's actually easy to get to.  Also
// encapsulates the building code.
private class LabelDialog : Dialog {
    Entry titleEntry, xLabelEntry, yLabelEntry;

    this(FigureWidget widget) {
        super();
        auto content = this.getContentArea();

        auto fb = widget.figure;
        auto sp = cast(Subplot) fb;
        if(sp) {
            auto zoomed = sp.zoomedFigure;
            if(zoomed) fb = zoomed;
        }

        // For some reason GTK complains about null text.  Fix it here.
        static string fixNull(string s) {
            return (s.length == 0) ? "\0" : s;
        }

        titleEntry = new Entry(
            fixNull(fb.title())
        );
        xLabelEntry = new Entry(
            fixNull(fb.xLabel())
        );
        yLabelEntry = new Entry(
            fixNull(fb.yLabel())
        );

        auto titleBox = new HBox(0, 5);
        titleBox.add(new Label("Title     "));
        titleBox.add(titleEntry);

        auto xLabelBox = new HBox(0, 5);
        xLabelBox.add(new Label("X Label"));
        xLabelBox.add(xLabelEntry);

        auto yLabelBox = new HBox(0, 5);
        yLabelBox.add(new Label("Y Label"));
        yLabelBox.add(yLabelEntry);

        content.add(titleBox);
        content.add(xLabelBox);
        content.add(yLabelBox);

        this.addButtons([StockID.OK, StockID.CANCEL],
            [GtkResponseType.GTK_RESPONSE_OK,
             GtkResponseType.GTK_RESPONSE_CANCEL]
        );
        this.setResizable(0);
    }
}

private class ZoomDialog : Dialog {
    Entry topEntry, bottomEntry, leftEntry, rightEntry;

    this(Figure fig) {
        super();
        auto content = this.getContentArea();

        topEntry = new Entry(to!string(fig.topMost));
        bottomEntry = new Entry(to!string(fig.bottomMost));
        leftEntry = new Entry(to!string(fig.leftMost));
        rightEntry = new Entry(to!string(fig.rightMost));

        auto topBox = new HBox(0, 5);
        topBox.add(new Label("Y Max"));
        topBox.add(topEntry);

        auto bottomBox = new HBox(0, 5);
        bottomBox.add(new Label("Y Min"));
        bottomBox.add(bottomEntry);

        auto leftBox = new HBox(0, 5);
        leftBox.add(new Label("X Min"));
        leftBox.add(leftEntry);

        auto rightBox = new HBox(0, 5);
        rightBox.add(new Label("X Max"));
        rightBox.add(rightEntry);

        content.add(leftBox);
        content.add(rightBox);
        content.add(bottomBox);
        content.add(topBox);

        this.addButtons([StockID.OK, StockID.CANCEL],
            [GtkResponseType.GTK_RESPONSE_OK,
             GtkResponseType.GTK_RESPONSE_CANCEL]
        );
        this.addButtons(["Default"], [cast(GtkResponseType) 1]);
        this.setResizable(0);
    }
}

/**Default plot window.  It's a subclass of either Window or MainWindow
 * depending on the template parameter.
 */
template DefaultPlotWindow(Base)
if(is(Base == gtk.Window.Window) || is(Base == gtk.MainWindow.MainWindow)) {

    ///
    class DefaultPlotWindow : Base {
    private:
        FigureWidget widget;
        Menu rightClickMenu;

        immutable string[8] saveTypes =
            ["*.png", "*.bmp", "*.tiff", "*.jpg", "*.jpeg", "*.eps",
             "*.pdf", "*.svg"];

        // Based on using print statements to figure it out.  If anyone can
        // find the right documentation and wants to convert this to a proper
        // enum, feel free.
        enum rightClick = 3;

        bool isValidExt(string ext) {
            foreach(t; saveTypes) {
                if(ext == t[2..$]) {
                    return true;
                }
            }

            return false;
        }

        Menu buildRightClickMenu() {
            auto ret = new Menu();

            auto saveItem = new MenuItem(&popupSaveDialog, "_Save...");
            ret.append(saveItem);

            auto labelItem = new MenuItem(&popupLabelDialog, "_Labels...");
            ret.append(labelItem);

            auto zoomItem = new MenuItem(&popupZoomDialog, "_Zoom...");
            ret.append(zoomItem);

            auto fontSubmenu = new Menu();
            fontSubmenu.append( new MenuItem(&doFont!"titleFont", "_Title"));
            fontSubmenu.append( new MenuItem(&doFont!"xLabelFont", "_X Label"));
            fontSubmenu.append( new MenuItem(&doFont!"yLabelFont", "_Y Label"));
            fontSubmenu.append( new MenuItem(&doFont!"axesFont", "_Axes"));

            ret.appendSubmenu("_Fonts", fontSubmenu);

            ret.showAll();
            return ret;
        }

        void doFont(string which)(MenuItem menuItem) {
            auto fb = widget.figure;

            auto sp = cast(Subplot) fb;
            if(sp) {
                auto zoomed = sp.zoomedFigure;
                if(zoomed) {
                    fb = zoomed;
                }
            }

            static if(which == "axesFont") {
                auto toChange = cast(Figure) fb;
                if(!toChange) {
                    errorMessage("Can't change axes font on a Subplot.");
                    return;
                }
            } else {
                alias fb toChange;
            }

            auto dialog = new FontSelectionDialog(which);
            auto oldFont = mixin("toChange." ~ which);
            dialog.setFontName(text(oldFont.name, ' ', oldFont.size));

            void doChanges(int responseID, Dialog d) {
                if(responseID != GtkResponseType.GTK_RESPONSE_OK) {
                    return;
                }

                auto newName = dialog.getFontName();
                auto ns = newName.split();
                enforce(ns.length >= 2);
                auto baseName = join(ns[0..$ - 1], " ");
                auto size = to!double(ns[$ - 1]);
                auto newFont = getFont(baseName, size);
                mixin("toChange." ~ which ~ "(newFont);");
            }

            dialog.addOnResponse(&doChanges);
            dialog.run();
            dialog.destroy();

            widget.queueDraw();
        }

        void popupLabelDialog(MenuItem menuItem) {
            auto dialog = new LabelDialog(widget);
            dialog.addOnResponse(&changeLabels);
            dialog.showAll();
            dialog.run();
        }

        void errorMessage(string msg) {
            auto msgbox = new MessageDialog(this,
                GtkDialogFlags.DESTROY_WITH_PARENT,
                GtkMessageType.ERROR,
                GtkButtonsType.CLOSE, msg);
            msgbox.addOnResponse(&closeError);
            msgbox.run();
            return;
        }

        void subplotZoomError() {
            errorMessage("Cannot zoom to coordinates on a subplot.");
        }

        void popupZoomDialog(MenuItem menuItem) {
            auto sp = cast(Subplot) widget.figure;
            if(sp && cast(Figure) sp.zoomedFigure is null) {
                subplotZoomError();
                return;
            }

            Figure fig;
            if(sp) {
                fig = cast(Figure) sp.zoomedFigure;  // Already checked for null.
            } else {
                fig = cast(Figure) widget.figure;
            }
            assert(fig);

            auto dialog = new ZoomDialog(fig);
            dialog.addOnResponse(&changeZoom);
            dialog.showAll();
            dialog.run();
        }

        // Change labels in response to a label dialog ok.
        void changeLabels(int responseID, Dialog dialog) {
            if(responseID != GtkResponseType.GTK_RESPONSE_OK) {
                dialog.destroy();
                return;
            }

            auto ldialog = cast(LabelDialog) dialog;
            assert(ldialog);

            auto fb = widget.figure;
            auto sp = cast(Subplot) fb;

            if(sp) {
                auto zoomed = sp.zoomedFigure;
                if(zoomed) fb = zoomed;
            }

            fb.title = ldialog.titleEntry.getText();
            fb.xLabel = ldialog.xLabelEntry.getText();
            fb.yLabel = ldialog.yLabelEntry.getText();

            widget.queueDraw();
            dialog.destroy();
        }

        void changeZoom(int responseID, Dialog dialog) {
            auto zdialog = cast(ZoomDialog) dialog;
            assert(zdialog);

            auto fb = widget.figure;
            Figure fig;
            auto sp = cast(Subplot) fb;

            if(sp) {
                auto zoomed = cast(Figure) sp.zoomedFigure;
                if(zoomed) {
                    fig = zoomed;
                } else {
                    subplotZoomError();
                    return;
                }
            } else {
                fig = cast(Figure) fb;
                assert(fig);
            }

            if(responseID == 1) {
                fig.defaultZoom();
            } else if(responseID == GtkResponseType.GTK_RESPONSE_OK) {
                double newXMin, newYMin, newXMax, newYMax;
                try {
                    newXMin = to!double(zdialog.leftEntry.getText().strip());
                    newXMax = to!double(zdialog.rightEntry.getText().strip());
                    newYMin = to!double(zdialog.bottomEntry.getText().strip());
                    newYMax = to!double(zdialog.topEntry.getText().strip());
                } catch(ConvException) {
                    errorMessage("Limits must be numeric.");
                    return;
                }

                if(newXMin >= newXMax) {
                    errorMessage("X Min must be less than X Max.");
                    return;
                }

                if(newYMin >= newYMax) {
                    errorMessage("Y Min must be less than Y Max.");
                    return;
                }

                if(!isFinite(newYMin) || !isFinite(newYMax) ||
                   !isFinite(newXMin) || !isFinite(newXMax)) {
                    errorMessage("Limits must be finite, not infinity or NaN.");
                    return;
                }

                fig.xLim(newXMin, newXMax);
                fig.yLim(newYMin, newYMax);
            }

            dialog.destroy();
            widget.queueDraw();
        }

        void closeError(int response, Dialog d) {
            enforce(response == GtkResponseType.GTK_RESPONSE_CLOSE);
            d.destroy();
        }

        void fileError(string eString) {
            errorMessage("File could not be successfully written.  " ~ eString);
        }

        // Bring up menu on right click.
        bool clickEvent(GdkEventButton* event, Widget widget) {
            if(event.button != rightClick) {
                return false;
            }

            rightClickMenu.popup(null, null, null, null, rightClick, 0);

            return true;
        }

        version(Windows) {
            // Use crappy deprecated file dialog to avoid DLL hell issues that
            // occur in certain configurations (for example, mine).
            // Specifically, if you have Win64 + Symantec Endpoint Protection +
            // a mounted network drive and you launch from a Cygwin terminal,
            // bringing up a save dialog will immediately cause an access
            // violation.  This is apparently caused by SnacNp64.dll, a 64-bit
            // DLL related to Symantec's network protection stuff, being loaded
            // into 32-bit address space.
            //
            // This code is kinda quick and dirty in hope that it will be
            // removed soon.  For example, it doesn't do overwrite
            // confirmation, or filters.  If the extension isn't valid, it
            // just defaults to a PNG.

            void saveDialogResponse(int response, Dialog d) {
                auto fc = cast(FileSelection) d;
                assert(fc);

                if(response != GtkResponseType.GTK_RESPONSE_OK) {
                    d.destroy();
                    return;
                }

                auto names = fc.getSelections();
                enforce(names.length == 1);
                auto name = names[0];

                auto ext = tolower(getExt(name));

                string fileType;
                if(isValidExt(ext)) {
                    fileType = ext;
                } else {
                    fileType = "png";  // Default since we don't have filters.
                }

                try {
                    widget.figure.saveToFile
                        (name, fileType, widget.getWidth, widget.getHeight);
                } catch(Exception e) {
                    fileError(e.toString());
                }

                d.destroy();
            }

            void popupSaveDialog(MenuItem menuItem) {
                auto fc = new FileSelection("Save plot...");
                fc.setSelectMultiple(0);
                fc.addOnResponse(&saveDialogResponse);

                fc.run();
            }

        } else {
            void saveDialogResponse(int response, Dialog d) {
                auto fc = cast(FileChooserDialog) d;
                assert(fc);

                if(response != GtkResponseType.GTK_RESPONSE_OK) {
                    d.destroy();
                    return;
                }

                string name = fc.getFilename();
                auto ext = tolower(getExt(name));

                string fileType;
                if(isValidExt(ext)) {
                    fileType = ext;
                } else {
                    fileType = fc.getFilter().getName();
                    name ~= '.';
                    name ~= fileType;
                }

                try {
                    widget.figure.saveToFile
                        (name, fileType, widget.getWidth, widget.getHeight);
                } catch(Exception e) {
                    fileError(e.toString());
                }

                d.destroy();
            }

            void popupSaveDialog(MenuItem menuItem) {
                auto fc = new FileChooserDialog("Save plot...", this,
                GtkFileChooserAction.SAVE);
                fc.setDoOverwriteConfirmation(1);  // Why isn't this the default?
                fc.addOnResponse(&saveDialogResponse);

                foreach(ext; saveTypes) {
                    auto filter = new FileFilter();
                    filter.setName(ext[2..$]);
                    filter.addPattern(ext);
                    fc.addFilter(filter);
                }

                fc.run();
            }
        }

    public:
        ///
        this(FigureWidget widget) {
            super("Plot Window.  Right-click to save plot.");
            this.widget = widget;
            this.add(widget);
            widget.setSizeRequest(
                widget.figure.defaultWindowWidth,
                widget.figure.defaultWindowHeight
            );
            this.resize(widget.getWidth, widget.getHeight);
            this.setSizeRequest(
                widget.figure.minWindowWidth,
                widget.figure.minWindowHeight
            );

            this.addOnButtonPress(&clickEvent);
            this.rightClickMenu = buildRightClickMenu();

            widget.addOnSizeAllocate(&widget.parentSizeChanged);
            widget.showAll();
            widget.queueDraw();
            this.showAll();
        }
    }
}

}
