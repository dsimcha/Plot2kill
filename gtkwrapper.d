/**
This file contains the GTK-specific parts of Plot2Kill and is publicly
imported by plot2kill.figure if compiled with GtkD.

Note:  The functions that need GTK to be initialized for their use automatically
       call gtk.Main.initCheck() to provide sane default initialization.  This
       is for convenience in programs that throw up a few simple plots and
       otherwise don't have a GUI.  If gtk.Main.init() is called before
       calling any function in this module that requires GTK to be initialized,
       the first call's settings take precedence and the calls from this
       module have no effect.

Copyright (C) 2010-2011 David Simcha

License:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */
module plot2kill.gtkwrapper;

version(dfl) {
} else {

import plot2kill.util;
import plot2kill.guiagnosticbase;
import plot2kill.subplot;
import plot2kill.figure;
import plot2kill.plot;

alias std.string.CaseSensitive CaseSensitive;

static import std.file;

import gdk.Color, gdk.GC, gtk.Widget, gdk.Drawable, gtk.DrawingArea,
    gtk.MainWindow, gtk.Main, gdk.Window, gtk.Container, gtk.Window,
    gdk.Pixbuf, gdk.Pixmap, gtkc.all, gtk.FileChooserDialog, gtk.Dialog,
    gtk.FileFilter, gobject.ObjectG, cairo.Context, cairo.FontFace,
    gtkc.cairotypes, cairo.PdfSurface, cairo.SvgSurface,
    cairo.PostScriptSurface, cairo.Surface, cairo.ImageSurface,
    gtk.FileSelection, gtk.MessageDialog, gtk.Menu, gtk.MenuItem,
    gtk.Entry, gtk.HBox, gtk.Label, gtk.FontSelectionDialog, gtk.RadioButton,
    gtk.HSeparator, gtk.CheckButton, gtk.SeparatorMenuItem, gtkc.gtk;

// Default initialize GTK.
package void defaultInit() {
    string[] args;
    Main.initCheck(args);
}

/**GTK's implementation of a color object.*/
struct Color {
    ubyte r;
    ubyte g;
    ubyte b;
}

/**Holds context for drawing lines.*/
struct Pen {
    Color color;
    double lineWidth;
}

/**Holds context for drawing rectangles.*/
struct Brush {
    Color color;
}

///
struct Point {
    ///
    int x;

    ///
    int y;
}

///
struct Rect {
    ///
    int x;

    ///
    int y;

    ///
    int width;

    ///
    int height;
}

///
struct Size {
    ///
    int width;

    ///
    int height;
}

/**Holds font information.*/
alias cairo.FontFace.FontFace font;

/**Get a color in a GUI framework-agnostic way.*/
Color getColor(ubyte red, ubyte green, ubyte blue) {
    return Color(red, green, blue);
}

/**Get a font in a GUI framework-agnostic way.*/
struct Font {
    FontFace face;
    string name;
    double size;
}

Font getFont(string fontName, double size) {
    auto slant = (fontName.indexOf("oblique", CaseSensitive.no) > -1) ?
        cairo_font_slant_t.OBLIQUE : cairo_font_slant_t.NORMAL;
    auto weight = (fontName.indexOf("bold", CaseSensitive.no) > -1) ?
        cairo_font_weight_t.BOLD : cairo_font_weight_t.NORMAL;


    return Font(
        Context.toyFontFaceCreate(
            fontName,
            slant,
            weight
        ), fontName, size
    );
}


///
enum TextAlignment {
    ///
    Left = 0,

    ///
    Center = 1,

    ///
    Right = 2
}

// This calls the relevant lib's method of cleaning up the given object, if
// any.
void doneWith(T)(T garbage) {
    static if(is(T : gdk.GC.GC) || is(T : gdk.Pixmap.Pixmap) ||
              is(T : gdk.Pixbuf.Pixbuf)) {
        // Most things seem to manage themselves fine, but these objects
        // leak like a seive.
        garbage.unref();

        // Since we're already in here be dragons territory, we may as well:
        core.memory.GC.free(cast(void*) garbage);
    } else static if(is(T : cairo.Context.Context) || is(T : cairo.Surface.Surface)) {

        static if(is(T : cairo.Surface.Surface)) {
            garbage.finish();
        }
        //garbage.destroy();
    }
}

/**The base class for both FigureBase and Subplot.  Holds common functionality
 * like saving and text drawing.
 */
abstract class FigureBase : GuiAgnosticBase {
private:
    enum ubyteMax = cast(double) ubyte.max;

    // See drawLine() for an explanation of these variables.
    PlotPoint[] prevLine;
    Pen lastLinePen;

    void saveImplPixmap
    (string filename, string type, double width, double height) {
        plot2kill.gtkwrapper.defaultInit();
        int w = roundTo!int(width);
        int h = roundTo!int(height);

        auto pixmap = new Pixmap(null, w, h, 24);
        scope(exit) doneWith(pixmap);

        auto c = new Context(pixmap);
        scope(exit) doneWith(c);

        this.drawTo(c, PlotRect(0, 0, w, h));
        auto pixbuf = new Pixbuf(pixmap, 0, 0, w, h);
        scope(exit) doneWith(pixbuf);

        int result = pixbuf.savev(filename, type, null, null);
        enforce(result, "File not saved successfully.");
    }

    void saveImplSurface
    (string filename, string type, double width, double height) {
        Surface surf;
        switch(type) {
            case "pdf":
                surf = PdfSurface.create(filename, width, height);
                break;
            case "eps":
                surf = PostScriptSurface.create(filename, width, height);
                break;
            case "svg":
                surf = SvgSurface.create(filename, width, height);
                break;
            case "png":
                surf = ImageSurface.create(cairo_format_t.RGB24,
                    roundTo!int(width), roundTo!int(height));
                break;
            default:
                enforce(0, "Invalid file format:  " ~ type);
        }

        enforce(surf, "Couldn't save file because surface couldn't be created.");
        auto context = Context.create(surf);

        this.drawTo(context, PlotRect(0,0, width, height));
        surf.flush();

        if(type == "png") {
            // So sue me for the cast.
            auto result = (cast(ImageSurface) surf).writeToPng(filename);
            enforce(result == cairo_status_t.SUCCESS, text(
                "Unsuccessfully wrote png.  Error:  ", result));
        }

        // This should really be a scope(exit) but using scope(exit) instead
        // of putting this line down here segfaults on Linux 64 for reasons
        // I don't understand.
        surf.finish();
    }

    void saveImplSvgz(string filename, double width, double height) {
        // An svgz file is just an SVG that's been compressed with gzip.

        static extern(C) cairo_status_t
        writeFunc(void* gzVoid, ubyte* dataPtr, uint len) {
            uchar[] data = dataPtr[0..len];

            auto gz = cast(Gzip*) gzVoid;
            gz.addData(data);
            return cairo_status_t.SUCCESS;
        }

        auto gz = Gzip(filename);
        scope(exit) gz.finish();

        auto surf = SvgSurface.createForStream
            (&writeFunc, cast(void*) &gz, width, height);

        scope(exit) doneWith(surf);
        auto context = Context.create(surf);
        scope(exit) doneWith(context);

        this.drawTo(context, PlotRect(0,0, width, height));
        surf.flush();
    }

    void finishLine() {
        if(!prevLine.length) return;
        assert(prevLine.length > 1);

        context.save();
        scope(exit) context.restore();
        context.newPath();

        auto c = lastLinePen.color;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);
        context.setLineWidth(lastLinePen.lineWidth);

        // If we're joining lines, it's always on a LineGraph or something,
        // where miter creates weird artifacts.  Bevel looks best.
        context.setLineJoin(cairo_line_join_t.BEVEL);

        context.moveTo(prevLine.front.x + xOffset, prevLine.front.y + yOffset);
        foreach(i; 1..prevLine.length) {
            auto point = prevLine[i];
            context.lineTo(point.x + xOffset, point.y + yOffset);
        }

        context.stroke();
        prevLine.length = 0;
        assumeSafeAppend(prevLine);
    }

protected:
    // Fonts tend to be different actual sizes on different GUI libs for a
    // given nominal size. This adjusts for that factor when setting default
    // fonts.
    enum fontSizeAdjust = 0;

    Context context;

public:
    // These are undocumented FOR A REASON:  They aren't part of the public
    // API, but package is so broken it's not usable.  All this stuff w/o
    // ddoc should only be messed with if you're a developer of this lib,
    // not if you want to use it as a black box.

    final void drawLine
    (Pen pen, double startX, double startY, double endX, double endY) {
        /* HACK ALERT:  The front end to this library is designed for each line
         * to be drawn as a discrete unit, but for line joining purposes,
         * lines need to be drawn in a single path in Cairo.  Therefore,
         * we save stuff here and only draw it when moving to a new continuous
         * line.
         */
        if(prevLine.length > 0) {
            if(startX != prevLine.back.x || startY != prevLine.back.y
            || pen != lastLinePen) {
                finishLine();
            }
        }

        // This can change by calling finishLine().  Need to check it again
        // instead of just using an else block.
        if(prevLine.length == 0) {
            prevLine ~= PlotPoint(startX, startY);
            lastLinePen = pen;
        }

        prevLine ~= PlotPoint(endX, endY);
    }

    final void drawLine(Pen pen, PlotPoint start, PlotPoint end) {
        this.drawLine(pen, start.x, start.y, end.x, end.y);
    }

    final void drawRectangle
    (Pen pen, double x, double y, double width, double height) {
        context.save();
        scope(exit) context.restore();
        context.newPath();

        auto c = pen.color;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);
        context.setLineWidth(pen.lineWidth);
        context.rectangle(x + xOffset, y + yOffset, width, height);
        context.stroke();
    }

    final void drawRectangle(Pen pen, Rect r) {
        this.drawRectangle(pen, r.x, r.y, width, height);
    }

    final void fillRectangle
    (Brush brush, double x, double y, double width, double height) {
        context.save();
        scope(exit) context.restore();
        context.newPath();

        auto c = brush.color;
        enum ubyteMax = cast(double) ubyte.max;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);
        context.rectangle(x + xOffset, y + yOffset, width, height);
        context.fill();
    }

    final void fillRectangle(Brush brush, Rect r) {
        this.fillRectangle(brush, r.x, r.y, r.width, r.height);
    }

    final void drawText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect,
        TextAlignment alignment
    ) {
        context.save();
        scope(exit) context.restore();
        context.newPath();

        drawTextCurrentContext(text, font, pointColor, rect, alignment);
    }

    final void drawTextCurrentContext(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect,
        TextAlignment alignment
    ) {
        alias rect r;  // save typing
        auto measurements = measureText(text, font);

        // The height added by stuff below the baseline for letters like "g"
        // and "y" throws off aligning text vertically.  Use the height of
        // "A", which is a tall letter with nothing below baseline, to
        // figure out where to start writing.
        immutable standardLetterHeight = measureText("A", font).height;

        if(measurements.width > rect.width) {
            alignment = TextAlignment.Left;
        }

        if(alignment == TextAlignment.Left) {
            r = PlotRect(
                r.x,
                r.y + standardLetterHeight,
                r.width,
                r.height
            );
        } else if(alignment == TextAlignment.Center) {
            r = PlotRect(
                r.x + (r.width - measurements.width) / 2,
                r.y + standardLetterHeight,
                r.width, r.height
            );
        } else if(alignment == TextAlignment.Right) {
            r = PlotRect(
                r.x + (r.width - measurements.width),
                r.y + standardLetterHeight,
                r.width, r.height
            );
        } else {
            assert(0);
        }

        //context.rectangle(r.x, r.y - measurements.height, r.width, r.height);
        //context.clip();
        context.setFontSize(font.size);
        context.setFontFace(font.face);

        alias pointColor c;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);

        context.setLineWidth(0.5);
        context.moveTo(r.x + xOffset, r.y + yOffset);
        context.textPath(text);
        context.fill();
    }

    final void drawText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect
    ) {
        drawText(text, font, pointColor, rect, TextAlignment.Left);
    }

    final void drawRotatedText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect,
        TextAlignment alignment
    ) {
        context.save();
        scope(exit) context.restore;
        context.newPath();

        alias rect r;  // save typing
        auto measurements = measureText(text, font);

        // The height added by stuff below the baseline for letters like "g"
        // and "y" throws off aligning text vertically.  Use the height of
        // "A", which is a tall letter with nothing below baseline, to
        // figure out where to start writing.
        immutable standardLetterHeight = measureText("A", font).height;

        immutable slack  = rect.height - measurements.width;
        if(slack < 0) {
            alignment = TextAlignment.Left;
        }

        if(alignment == TextAlignment.Left) {
            r = PlotRect(
                r.x + standardLetterHeight,
                r.y + r.height,
                r.width,
                r.height
            );
        } else if(alignment == TextAlignment.Center) {
            r = PlotRect(
                r.x + standardLetterHeight,
                r.y + r.height - slack / 2,
                r.width, r.height
            );
        } else if(alignment == TextAlignment.Right) {
            r = PlotRect(
                r.x + standardLetterHeight,
                r.y + r.height - slack,
                r.width, r.height
            );
        } else {
            assert(0);
        }
        //context.rectangle(r.x, r.y - measurements.height, r.width, r.height);
        //context.clip();
        context.setFontSize(font.size);
        context.setFontFace(font.face);

        alias pointColor c;
        context.setSourceRgb(c.r / ubyteMax, c.g / ubyteMax, c.b / ubyteMax);

        context.setLineWidth(0.5);
        context.moveTo(r.x + xOffset, r.y + yOffset);
        context.rotate(PI * 1.5);
        context.textPath(text);
        context.fill();
    }

    final void drawRotatedText(
        string text,
        Font font,
        Color pointColor,
        PlotRect rect
    ) {
        drawRotatedText(text, font, pointColor, rect, TextAlignment.Left);
    }

    // BUGS:  Ignores maxWidth.
    final PlotSize measureText
    (string text, Font font, double maxWidth, TextAlignment alignment) {
        return measureText(text, font);
    }

    // BUGS:  Ignores maxWidth.
    final PlotSize measureText(string text, Font font, double maxWidth) {
        return measureText(text, font);

    }

    final PlotSize measureText(string text, Font font) {
        context.save();
        scope(exit) context.restore();

        context.setLineWidth(1);
        context.setFontSize(font.size);
        context.setFontFace(font.face);
        cairo_text_extents_t ext;

        context.textExtents(text, &ext);
        return PlotSize(ext.width, ext.height);
    }

    // TODO:  Add support for stuff other than solid brushes.
    /*Get a brush in a GUI framework-agnostic way.*/
    static Brush getBrush(Color color) {
        return Brush(color);
    }

    /*Get a pen in a GUI framework-agnostic way.*/
    static Pen getPen(Color color, double width = 1) {
        return Pen(color, width);
    }

    void drawTo(Context context) {
        drawTo(context, this.width, this.height);
    }

    void drawTo(Context context, double width, double height) {
        return drawTo(context, PlotRect(0, 0, width, height));
    }

    // Allows drawing at an offset from the origin.
    void drawTo(Context context, PlotRect whereToDraw) {
        enforceSane(whereToDraw);
        // Save the default class-level values, make the values passed in the
        // class-level values, call drawImpl(), then restore the default values.
        auto oldContext = this.context;
        auto oldWidth = this._width;
        auto oldHeight = this._height;
        auto oldXoffset = this.xOffset;
        auto oldYoffset = this.yOffset;

        scope(exit) {
            this.context = oldContext;
            this._height = oldHeight;
            this._width = oldWidth;
            this.xOffset = oldXoffset;
            this.yOffset = oldYoffset;
        }

        this.context = context;
        this._width = whereToDraw.width;
        this._height = whereToDraw.height;
        this.xOffset = whereToDraw.x;
        this.yOffset = whereToDraw.y;
        drawImpl();
        finishLine();
    }

    /**Saves this figure to a file.  The file type can be one of either the
     * raster formats .png, .jpg, .tiff, and .bmp, or the vector formats
     * .pdf, .svg and .eps.  The width and height parameters allow you to
     * specify explicit width and height parameters for the image file.  If
     * width and height are left at their default values
     * of 0, the default width and height of the subclass being saved will
     * be used.
     *
     * Bugs:  .jpg, .tiff and .bmp formats rely on Pixmap objects, meaning
     *        you can't save them to a file unless you have a screen and
     *        have called Main.init(), even though saving should have
     *        nothing to do with X or screens.
     */
    void saveToFile
    (string filename, string type, double width = 0, double height = 0) {
        // User friendliness:  Remove . if it was included, don't be case sens.
        type = toLower(type);
        if(!type.empty && type.front == '.') {
            type.popFront();
        }
        if(type == "jpg") {
            type = "jpeg";
        }

        if(width == 0 || height == 0) {
            width = this.defaultWindowWidth;
            height = this.defaultWindowHeight;
        }

        if(type == "eps" || type == "pdf" || type == "svg" || type == "png") {
            return saveImplSurface(filename, type, width, height);
        } else if(type == "svgz") {
            return saveImplSvgz(filename, width, height);
        } else {
            enforce(type == "tiff" || type == "bmp" || type == "jpeg",
                "Invalid format:  " ~ type);
            return saveImplPixmap(filename, type, width, height);
        }
    }

    /**Convenience function that infers the type from the filename extenstion
     * and defaults to .png if no valid file format extension is found.
     */
    void saveToFile(string filename, double width = 0, double height = 0) {
        auto type = toLower(extensionNoDot(filename));

        try {
            saveToFile(filename, type, width, height);
        } catch {
            // Default to png.
            saveToFile(filename, "png", width, height);
        }
    }

    /**Creates a Widget that will have this object drawn to it.  This Widget
     * can be displayed in a window.
     */
    FigureWidget toWidget() {
        defaultInit();
        return new FigureWidget(this);
    }

    /**Draw and display the figure as a main form.  This is useful in
     * otherwise console-based apps that want to display a few plots.
     * However, you can't have another main form up at the same time.
     */
    void showAsMain() {
        auto mw = new DefaultPlotWindow!(MainWindow)(this.toWidget);
        Main.run();
    }

    /**Returns a default plot window with this figure in it.*/
    gtk.Window.Window getDefaultWindow() {
        return new DefaultPlotWindow!(gtk.Window.Window)(this.toWidget);
    }
}

// Used for scatter plots.  Efficiently draws a single character in a lot of
// places, centered on a point.  ASSUMPTION:  No drawing commands not related
// to drawing scatter plot points are issued between when initialize()
// and reset() are called.
package struct ScatterCharDrawer {
private:
    string str;
    PlotSize halfMeasurements;
    Figure fig;
    Font font;
    float red, green, blue;

public:
    this(dchar c, Font font, Color color, Figure fig) {
        str = to!string(c);
        this.fig = fig;
        this.font = font;

        red = color.r / cast(float) ubyte.max;
        green = color.g / cast(float) ubyte.max;
        blue = color.b / cast(float) ubyte.max;


        auto measurements = fig.measureText(str, font);
        halfMeasurements = PlotSize(measurements.width / 2,
            measurements.height / 2);
    }

    void draw(PlotPoint where) {
        with(fig) {
            if(!insideAxes(where)) return;
            context.moveTo(where.x + xOffset - halfMeasurements.width,
                where.y + yOffset + halfMeasurements.height);
            context.textPath(str);
            context.fill();
        }
    }

    // Initialize the Cairo context to the settings we need.
    void initialize() {
        with(fig) {
            context.save();

            // Set up a clip region.
            context.moveTo(leftMargin + xOffset, topMargin + yOffset);
            context.lineTo(leftMargin + xOffset,
                fig.height - bottomMargin + yOffset);
            context.lineTo(fig.width - rightMargin + xOffset,
                fig.height - bottomMargin + yOffset);
            context.lineTo(fig.width - rightMargin + xOffset,
                topMargin + yOffset);
            context.lineTo(leftMargin + xOffset, topMargin + yOffset);
            context.clip();

            context.setFontSize(font.size);
            context.setFontFace(font.face);
            context.setSourceRgb(red, green, blue);
            context.setLineWidth(0.5);
        }
    }

    // Restore the Cairo context to the old settings.
    void restore() {
        fig.context.restore();
    }
}

/*
This class allows a legend symbol to be drawn in a small area.  This really
needs to be refactored to separate the GUI wrapping code from FigureBase,
but I'm too lazy to do it for now.
*/
private class LegendSymbolDrawer : FigureBase {
    Plot plot;

    this(Plot plot) {
        this._width = legendSymbolSize;
        this._height = legendSymbolSize;
        this.plot = plot;
    }

    override void drawImpl() {
        try {
            auto rect = Rect(0, 0, legendSymbolSize, legendSymbolSize);
            auto prect = PlotRect(0, 0, legendSymbolSize, legendSymbolSize);
            auto brush = getBrush(getColor(255, 255, 255));
            scope(exit) doneWith(brush);
            fillRectangle(brush, rect);
            plot.drawLegendSymbol(this, prect);
        } catch(Exception) {
            // Legend not implemented for plot type.  This is ok to ignore.
        }
    }

    override int defaultWindowWidth() { return legendSymbolSize; }
    override int defaultWindowHeight() { return legendSymbolSize; }
    override int minWindowWidth() { return legendSymbolSize; }
    override int minWindowHeight() { return legendSymbolSize; }
}


/**The default widget for displaying Figure and Subplot objects on screen.
 * This class has no public constructor or static factory method because the
 * proper way to instantiate this object is via the toWidget properties
 * of FigureBase and Subplot.
 */
class FigureWidget : DrawingArea {
private:
    FigureBase _figure;

package:
    this(FigureBase fig) {
        super();
        this._figure = fig;
        this.addOnExpose(&onDrawingExpose);
        this.setSizeRequest(fig.minWindowWidth, fig.minWindowHeight);
    }

    bool onDrawingExpose(GdkEventExpose* event, Widget drawingArea) {
        draw();
        return true;
    }

    void draw(double w, double h) {
        enforce(getParent() !is null, this.classinfo.name);
        auto context = new Context(getWindow());
        scope(exit) doneWith(context);

        figure.drawTo(context, w, h);
    }

public:
    /**Get the underlying FigureBase object.*/
    final FigureBase figure() @property {
        return _figure;
    }

    /**If set as an addOnSizeAllocate callback, this will resize this control
     * to the size of its parent window when the parent window is resized.
     */
    void parentSizeChanged(GtkAllocation* alloc, Widget widget) {
        if(this.getWidth != alloc.width || this.getHeight != alloc.height) {
            this.setSizeRequest(alloc.width, alloc.height);
        }
    }

    /**Draw the figure to the internal drawing area.*/
    final void draw() {
        draw(this.getWidth, this.getHeight);
    }

}

// Convenience subclass of Dialog that has the entries for title, xlabel
// and ylabel available in a way that's actually easy to get to.  Also
// encapsulates the building code.
private class LabelDialog : Dialog {
    Entry titleEntry, xLabelEntry, yLabelEntry;

    this(FigureWidget widget) {
        super();
        setTitle("Labels");
        auto content = this.getContentArea();

        auto fb = widget.figure;
        auto sp = cast(Subplot) fb;
        if(sp) {
            auto zoomed = sp.zoomedFigure;
            if(zoomed) fb = zoomed;
        }

        // For some reason GTK complains about null text.  Fix it here.
        static string fixNull(string s) {
            return (s.length == 0) ? "\0" : s;
        }

        titleEntry = new Entry(
            fixNull(fb.title())
        );
        xLabelEntry = new Entry(
            fixNull(fb.xLabel())
        );
        yLabelEntry = new Entry(
            fixNull(fb.yLabel())
        );

        titleEntry.setActivatesDefault(1);
        xLabelEntry.setActivatesDefault(1);
        yLabelEntry.setActivatesDefault(1);

        auto titleBox = new HBox(0, 5);
        titleBox.add(new Label("Title     "));
        titleBox.add(titleEntry);

        auto xLabelBox = new HBox(0, 5);
        xLabelBox.add(new Label("X Label"));
        xLabelBox.add(xLabelEntry);

        auto yLabelBox = new HBox(0, 5);
        yLabelBox.add(new Label("Y Label"));
        yLabelBox.add(yLabelEntry);

        content.add(titleBox);
        content.add(xLabelBox);
        content.add(yLabelBox);

        this.addButtons([StockID.OK, StockID.CANCEL],
            [GtkResponseType.GTK_RESPONSE_OK,
             GtkResponseType.GTK_RESPONSE_CANCEL]
        );
        this.setDefaultResponse(GtkResponseType.GTK_RESPONSE_OK);
        this.setResizable(0);
    }
}

private class ZoomDialog : Dialog {
    Entry topEntry, bottomEntry, leftEntry, rightEntry;

    this(Figure fig) {
        super();
        setTitle("Zoom");
        auto content = this.getContentArea();

        topEntry = new Entry(to!string(fig.topMost));
        bottomEntry = new Entry(to!string(fig.bottomMost));
        leftEntry = new Entry(to!string(fig.leftMost));
        rightEntry = new Entry(to!string(fig.rightMost));

        topEntry.setActivatesDefault(1);
        bottomEntry.setActivatesDefault(1);
        leftEntry.setActivatesDefault(1);
        rightEntry.setActivatesDefault(1);

        auto topBox = new HBox(0, 5);
        topBox.add(new Label("Y Max"));
        topBox.add(topEntry);

        auto bottomBox = new HBox(0, 5);
        bottomBox.add(new Label("Y Min"));
        bottomBox.add(bottomEntry);

        auto leftBox = new HBox(0, 5);
        leftBox.add(new Label("X Min"));
        leftBox.add(leftEntry);

        auto rightBox = new HBox(0, 5);
        rightBox.add(new Label("X Max"));
        rightBox.add(rightEntry);

        content.add(leftBox);
        content.add(rightBox);
        content.add(bottomBox);
        content.add(topBox);

        this.addButtons([StockID.OK, StockID.CANCEL],
            [GtkResponseType.GTK_RESPONSE_OK,
             GtkResponseType.GTK_RESPONSE_CANCEL]
        );
        this.setDefaultResponse(GtkResponseType.GTK_RESPONSE_OK);
        this.addButtons(["Default"], [cast(GtkResponseType) 1]);
        this.setResizable(0);
    }
}

private class LegendDialog : Dialog {
    Entry[] entries;
    RadioButton topRadio, bottomRadio, leftRadio,rightRadio;

    this(Figure fig) {
        super();
        setTitle("Legend");
        auto content = this.getContentArea();

        content.add(new Label("Position"));
        auto posBox1 = new HBox(1, 5);
        auto posBox2 = new HBox(1, 5);
        topRadio = new RadioButton("Top");
        bottomRadio = new RadioButton(topRadio, "Bottom");
        leftRadio = new RadioButton(topRadio, "Left");
        rightRadio = new RadioButton(topRadio, "Right");

        final switch(fig.legendLocation()) {
            case LegendLocation.left:
                leftRadio.setActive(1);
                break;
            case LegendLocation.right:
                rightRadio.setActive(1);
                break;
            case LegendLocation.top:
                topRadio.setActive(1);
                break;
            case LegendLocation.bottom:
                bottomRadio.setActive(1);
                break;
        }

        posBox1.add(topRadio);
        posBox1.add(bottomRadio);
        posBox2.add(leftRadio);
        posBox2.add(rightRadio);

        content.add(posBox1);
        content.add(posBox2);
        content.add(new HSeparator);

        foreach(plot; fig.plotData) if(plot.hasLegend()) {
            auto symbolDrawer = new LegendSymbolDrawer(plot);
            auto widget = new FigureWidget(symbolDrawer);

            auto ltext = plot.legendText();
            if(!ltext.length) ltext = "\0";
            auto box = new HBox(0, 5);
            box.add(widget);

            auto entry = new Entry(ltext);
            entry.setActivatesDefault(1);
            entries ~= entry;
            box.add(entry);
            content.add(box);
        }

        this.addButtons([StockID.OK, StockID.CANCEL],
            [GtkResponseType.GTK_RESPONSE_OK,
             GtkResponseType.GTK_RESPONSE_CANCEL]
        );
        this.setDefaultResponse(GtkResponseType.GTK_RESPONSE_OK);
        this.setResizable(0);
    }
}

class TickDialog(char xy) : Dialog {
    Entry locEntry, labelEntry, gridEntry;
    CheckButton rotateButton, gridLineButton;
    enum upperXY = cast(char) (xy + ('X' - 'x'));
    enum grid = (xy == 'x') ? "vertical" : "horizontal";

    this(Figure fig) {
        super();
        setTitle(upperXY ~ " Ticks");
        auto content = this.getContentArea();

        auto instructions = new Label(
            "Enter labels and locations as comma-separated lists. Commas may\n" ~
            "be escaped using the \\ character.  Labels may be left blank, in\n" ~
            "which case they will be set to the string representations of locations.\n\n" ~
            "The default button causes the default heuristics for tick locations\n" ~
            "to be used, but still updates the grid lines and rotated label text\n"
            "settings."
        );
        content.add(instructions);

        content.add(new HSeparator());

        auto locBox = new HBox(0, 5);
        locBox.add(new Label("Locations"));
        locEntry = new Entry();

        auto stringLocs = mixin("to!(string[])(fig." ~ xy ~ "AxisLocations)");
        auto joined = std.string.join(stringLocs, ", ");
        locEntry.setText(joined);
        locEntry.setSizeRequest(400, locEntry.getHeight());
        locEntry.setActivatesDefault(1);
        locBox.add(locEntry);
        content.add(locBox);

        auto labelBox = new HBox(0, 5);
        labelBox.add(new Label("Labels     "));
        labelEntry = new Entry();

        auto labelText = mixin("fig." ~ xy ~ "AxisText");
        string flattened;

        foreach(i, elem; labelText) {
            elem = elem.replace(r"\", r"\\").replace(",", r"\,");
            flattened ~= elem;
            if(i < labelText.length - 1) {
                flattened ~= ", ";
            }
        }

        labelEntry.setText(flattened);
        labelEntry.setSizeRequest(400, locEntry.getHeight());
        labelEntry.setActivatesDefault(1);
        labelBox.add(labelEntry);
        content.add(labelBox);

        rotateButton = new CheckButton("Rotate Label Text");
        immutable rotated = mixin("fig.rotated" ~ upperXY ~ "Tick()");
        rotateButton.setActive(cast(int) rotated);

        gridLineButton = new CheckButton("Grid Lines");
        immutable grid = mixin("fig." ~ grid ~ "Grid()");
        gridLineButton.setActive(cast(int) grid);

        content.add(new HSeparator());
        auto checkHbox = new HBox(0, 5);
        checkHbox.add(rotateButton);
        checkHbox.add(gridLineButton);

        auto intensLabel = new Label("Gridline Intensity (0-255)");
        intensLabel.setJustify(GtkJustification.JUSTIFY_RIGHT);
        checkHbox.add(intensLabel);

        gridEntry = new Entry();
        gridEntry.setMaxLength(3);
        gridEntry.setWidthChars(3);
        gridEntry.setText(to!string(fig.gridIntensity()));
        checkHbox.add(gridEntry);
        content.add(checkHbox);

        this.addButtons([StockID.OK, StockID.CANCEL],
            [GtkResponseType.GTK_RESPONSE_OK,
             GtkResponseType.GTK_RESPONSE_CANCEL]
        );
        this.setDefaultResponse(GtkResponseType.GTK_RESPONSE_OK);
        this.addButtons(["Default"], [cast(GtkResponseType) 1]);
        this.setResizable(0);
    }
}

/**Default plot window.  It's a subclass of either Window or MainWindow
 * depending on the template parameter.
 */
template DefaultPlotWindow(Base)
if(is(Base == gtk.Window.Window) || is(Base == gtk.MainWindow.MainWindow)) {

    ///
    class DefaultPlotWindow : Base {
    private:
        FigureWidget widget;
        Menu rightClickMenu;

        static immutable string[9] saveTypes =
            ["*.png", "*.bmp", "*.tiff", "*.jpg", "*.jpeg", "*.eps",
             "*.pdf", "*.svg", "*.svgz"];

        // Based on using print statements to figure it out.  If anyone can
        // find the right documentation and wants to convert this to a proper
        // enum, feel free.
        enum rightClick = 3;

        bool isValidExt(string ext) {
            foreach(t; saveTypes) {
                if(ext == t[2..$]) {
                    return true;
                }
            }

            return false;
        }

        Menu buildRightClickMenu() {
            auto ret = new Menu();

            auto saveItem = new MenuItem(&popupSaveDialog, "_Save...");
            ret.append(saveItem);

            auto labelItem = new MenuItem(&popupLabelDialog, "_Labels...");
            ret.append(labelItem);

            auto legendItem = new MenuItem(&popupLegendDialog, "Le_gend...");
            ret.append(legendItem);

            auto zoomItem = new MenuItem(&popupZoomDialog, "_Zoom...");
            ret.append(zoomItem);

            ret.append(new SeparatorMenuItem());
            auto xTickItem = new MenuItem(&popupTickDialog!'x', "_X Ticks...");
            auto yTickItem = new MenuItem(&popupTickDialog!'y', "_Y Ticks...");
            ret.append(xTickItem);
            ret.append(yTickItem);
            ret.append(new SeparatorMenuItem());

            auto fontSubmenu = new Menu();
            fontSubmenu.append( new MenuItem(&doFont!"titleFont", "_Title"));
            fontSubmenu.append( new MenuItem(&doFont!"xLabelFont", "_X Label"));
            fontSubmenu.append( new MenuItem(&doFont!"yLabelFont", "_Y Label"));
            fontSubmenu.append( new MenuItem(&doFont!"axesFont", "_Axes"));
            fontSubmenu.append( new MenuItem(&doFont!"legendFont", "_Legend"));

            ret.appendSubmenu("_Fonts", fontSubmenu);

            ret.showAll();
            return ret;
        }

        void doFont(string which)(MenuItem menuItem) {
            auto fb = widget.figure;

            auto sp = cast(Subplot) fb;
            if(sp) {
                auto zoomed = sp.zoomedFigure;
                if(zoomed) {
                    fb = zoomed;
                }
            }

            static if(which == "axesFont" || which == "legendFont") {
                auto toChange = cast(Figure) fb;
                if(!toChange) {
                    errorMessage("Can't change axes, legend fonts on a Subplot.");
                    return;
                }
            } else {
                alias fb toChange;
            }

            auto dialog = new FontSelectionDialog(which);
            auto oldFont = mixin("toChange." ~ which);
            dialog.setFontName(text(oldFont.name, ' ', oldFont.size));

            void doChanges(int responseID, Dialog d) {
                if(responseID != GtkResponseType.GTK_RESPONSE_OK) {
                    return;
                }

                auto newName = dialog.getFontName();
                auto ns = newName.split();
                enforce(ns.length >= 2);
                auto baseName = join(ns[0..$ - 1], " ");
                auto size = to!double(ns[$ - 1]);
                auto newFont = getFont(baseName, size);
                mixin("toChange." ~ which ~ "(newFont);");
            }

            dialog.addOnResponse(&doChanges);
            dialog.run();
            dialog.destroy();

            widget.queueDraw();
        }

        void popupTickDialog(char xy)(MenuItem menuItem) {
            auto fb = widget.figure;
            auto sp = cast(Subplot) fb;

            Figure fig;
            if(sp) {
                fig = cast(Figure) sp.zoomedFigure;
            } else {
                fig = cast(Figure) fb;
            }

            if(!fig) {
                errorMessage("Cannot change " ~ xy ~ " ticks on a subplot.");
                return;
            }

            auto dialog = new TickDialog!xy(fig);

            void changeTicks(int responseID, Dialog dummy) {
                if(responseID == GtkResponseType.GTK_RESPONSE_CANCEL) {
                    dialog.destroy();
                    return;
                }

                auto rotation = cast(bool) dialog.rotateButton.getActive();
                auto grid = cast(bool) dialog.gridLineButton.getActive();

                ubyte gridIntens;
                try {
                    gridIntens = to!ubyte(dialog.gridEntry.getText());
                } catch(ConvException) {
                    errorMessage("Grid intensity must be a numeric, 0-255.");
                    return;
                }

                enum upperXY = dialog.upperXY;
                enum gridStr = dialog.grid;
                mixin("fig.rotated" ~ upperXY ~ "Tick(rotation);");
                mixin("fig." ~ gridStr ~ "Grid(grid);");
                fig.gridIntensity(gridIntens);

                if(responseID == 1) {  // Set to default.
                    mixin("fig.default" ~ upperXY ~ "Tick();");
                    dialog.destroy();
                    queueDraw();
                    return;
                }

                double[] locations;
                auto locText = dialog.locEntry.getText();
                auto locSplit = splitEscape(locText);
                try {
                    locations = to!(double[])(locSplit);
                } catch(ConvException) {
                    errorMessage("Locations must be numeric.");
                    return;
                }

                if(!filter!(not!isFinite)(locations).empty) {
                    errorMessage("Locations must be finite, not NaN or infinity.");
                    return;
                }


                auto labelText = dialog.labelEntry.getText();
                if(labelText.strip().length == 0) {
                    labelText = locText;
                }

                auto labels = splitEscape(labelText);
                if(labels.length != locations.length) {
                    errorMessage("Locations and labels must be same length.");
                    return;
                }

                mixin("fig." ~ xy ~ "TickLabels(locations, labels);");
                dialog.destroy();
                queueDraw();
            }

            dialog.addOnResponse(&changeTicks);
            dialog.showAll();
            dialog.run();
        }

        void popupLegendDialog(MenuItem menuItem) {
            auto fb = widget.figure;
            auto sp = cast(Subplot) fb;

            Figure fig;
            if(sp) {
                fig = cast(Figure) sp.zoomedFigure;
            } else {
                fig = cast(Figure) fb;
            }

            if(!fig) {
                errorMessage("Cannot change legend on a subplot.");
                return;
            }

            auto dialog = new LegendDialog(fig);

            void changeLegend(int responseID, Dialog dummy) {
                if(responseID != GtkResponseType.GTK_RESPONSE_OK) {
                    return;
                }

                foreach(i, plot; fig.plotData) if(plot.hasLegend()) {
                    auto entryText = dialog.entries[i].getText();
                    if(entryText == "\0") entryText = "";
                    plot.legendText(entryText);
                }

                if(dialog.topRadio.getActive()) {
                    fig.legendLocation(LegendLocation.top);
                } else if(dialog.bottomRadio.getActive()) {
                    fig.legendLocation(LegendLocation.bottom);
                } else if(dialog.leftRadio.getActive()) {
                    fig.legendLocation(LegendLocation.left);
                } else if(dialog.rightRadio.getActive()) {
                    fig.legendLocation(LegendLocation.right);
                } else {
                    assert(0);
                }

                queueDraw();
            }

            dialog.addOnResponse(&changeLegend);
            dialog.showAll();
            dialog.run();
            dialog.destroy();
        }

        void popupLabelDialog(MenuItem menuItem) {
            auto dialog = new LabelDialog(widget);
            dialog.addOnResponse(&changeLabels);
            dialog.showAll();
            dialog.run();
        }

        void errorMessage(string msg) {
            auto msgbox = new MessageDialog(this,
                GtkDialogFlags.DESTROY_WITH_PARENT,
                GtkMessageType.ERROR,
                GtkButtonsType.CLOSE, msg);
            msgbox.addOnResponse(&closeError);
            msgbox.run();
            return;
        }

        void subplotZoomError() {
            errorMessage("Cannot zoom to coordinates on a subplot.");
        }

        void popupZoomDialog(MenuItem menuItem) {
            auto sp = cast(Subplot) widget.figure;
            if(sp && cast(Figure) sp.zoomedFigure is null) {
                subplotZoomError();
                return;
            }

            Figure fig;
            if(sp) {
                fig = cast(Figure) sp.zoomedFigure;  // Already checked for null.
            } else {
                fig = cast(Figure) widget.figure;
            }
            assert(fig);

            auto dialog = new ZoomDialog(fig);
            dialog.addOnResponse(&changeZoom);
            dialog.showAll();
            dialog.run();
        }

        // Change labels in response to a label dialog ok.
        void changeLabels(int responseID, Dialog dialog) {
            if(responseID != GtkResponseType.GTK_RESPONSE_OK) {
                dialog.destroy();
                return;
            }

            auto ldialog = cast(LabelDialog) dialog;
            enforce(ldialog);

            auto fb = widget.figure;
            auto sp = cast(Subplot) fb;

            if(sp) {
                auto zoomed = sp.zoomedFigure;
                if(zoomed) fb = zoomed;
            }

            fb.title = ldialog.titleEntry.getText();
            fb.xLabel = ldialog.xLabelEntry.getText();
            fb.yLabel = ldialog.yLabelEntry.getText();

            widget.queueDraw();
            dialog.destroy();
        }

        void changeZoom(int responseID, Dialog dialog) {
            auto zdialog = cast(ZoomDialog) dialog;
            enforce(zdialog);

            auto fb = widget.figure;
            Figure fig;
            auto sp = cast(Subplot) fb;

            if(sp) {
                auto zoomed = cast(Figure) sp.zoomedFigure;
                if(zoomed) {
                    fig = zoomed;
                } else {
                    subplotZoomError();
                    return;
                }
            } else {
                fig = cast(Figure) fb;
                enforce(fig);
            }

            if(responseID == 1) {
                fig.defaultZoom();
            } else if(responseID == GtkResponseType.GTK_RESPONSE_OK) {
                double newXMin, newYMin, newXMax, newYMax;
                try {
                    newXMin = to!double(zdialog.leftEntry.getText().strip());
                    newXMax = to!double(zdialog.rightEntry.getText().strip());
                    newYMin = to!double(zdialog.bottomEntry.getText().strip());
                    newYMax = to!double(zdialog.topEntry.getText().strip());
                } catch(ConvException) {
                    errorMessage("Limits must be numeric.");
                    return;
                }

                if(newXMin >= newXMax) {
                    errorMessage("X Min must be less than X Max.");
                    return;
                }

                if(newYMin >= newYMax) {
                    errorMessage("Y Min must be less than Y Max.");
                    return;
                }

                if(!isFinite(newYMin) || !isFinite(newYMax) ||
                   !isFinite(newXMin) || !isFinite(newXMax)) {
                    errorMessage("Limits must be finite, not infinity or NaN.");
                    return;
                }

                fig.xLim(newXMin, newXMax);
                fig.yLim(newYMin, newYMax);
            }

            dialog.destroy();
            widget.queueDraw();
        }

        void closeError(int response, Dialog d) {
            enforce(response == GtkResponseType.GTK_RESPONSE_CLOSE);
            d.destroy();
        }

        void fileError(string eString) {
            errorMessage("File could not be successfully written.  " ~ eString);
        }

        // Bring up menu on right click.
        bool clickEvent(GdkEventButton* event, Widget widget) {
            if(event.button != rightClick) {
                return false;
            }

            rightClickMenu.popup(null, null, null, null, rightClick,
                gtk_get_current_event_time());

            return true;
        }

        // Use crappy deprecated file dialog to avoid DLL hell issues that
        // occur in certain configurations (for example, mine).
        // Specifically, if you have Win64 + Symantec Endpoint Protection +
        // a mounted network drive and you launch from a Cygwin terminal,
        // bringing up a save dialog will immediately cause an access
        // violation.  This is apparently caused by SnacNp64.dll, a 64-bit
        // DLL related to Symantec's network protection stuff, being loaded
        // into 32-bit address space.
        //
        // This code is kinda quick and dirty in hope that it will be
        // removed soon.  For example, it doesn't do overwrite
        // confirmation, or filters.  If the extension isn't valid, it
        // just defaults to a PNG.
        void popupSaveDialogFallback(MenuItem menuItem) {
            auto fc = new FileSelection("Save plot...");
            fc.setSelectMultiple(0);
            fc.addOnResponse(&saveDialogResponseFallback);

            fc.run();
        }

        void saveDialogResponseFallback(int response, Dialog d) {
            auto fc = cast(FileSelection) d;
            assert(fc);

            if(response != GtkResponseType.GTK_RESPONSE_OK) {
                d.destroy();
                return;
            }

            auto names = fc.getSelections();
            enforce(names.length == 1);
            auto name = names[0];

            auto ext = toLower(extensionNoDot(name));

            string fileType;
            if(isValidExt(ext)) {
                fileType = ext;
            } else {
                fileType = "png";  // Default since we don't have filters.
            }

            try {
                widget.figure.saveToFile
                    (name, fileType, widget.getWidth, widget.getHeight);
            } catch(Exception e) {
                fileError(e.toString());
            }

            d.destroy();
        }

        void saveDialogResponse(int response, Dialog d) {
            auto fc = cast(FileChooserDialog) d;
            assert(fc);

            if(response != GtkResponseType.GTK_RESPONSE_OK) {
                d.destroy();
                return;
            }

            string name = fc.getFilename();
            auto ext = toLower(extensionNoDot(name));

            string fileType;
            if(isValidExt(ext)) {
                fileType = ext;
            } else {
                fileType = fc.getFilter().getName();
                name ~= '.';
                name ~= fileType;
            }

            try {
                widget.figure.saveToFile
                    (name, fileType, widget.getWidth, widget.getHeight);
            } catch(Exception e) {
                fileError(e.toString());
            }

            d.destroy();
        }

        void popupSaveDialogImpl(MenuItem menuItem) {
            auto fc = new FileChooserDialog("Save plot...", this,
            GtkFileChooserAction.SAVE);
            fc.setDoOverwriteConfirmation(1);  // Why isn't this the default?
            fc.addOnResponse(&saveDialogResponse);

            foreach(ext; saveTypes) {
                auto filter = new FileFilter();
                filter.setName(ext[2..$]);
                filter.addPattern(ext);
                fc.addFilter(filter);
            }

            fc.run();
        }

        void popupSaveDialog(MenuItem menuItem) {
            try {
                popupSaveDialogImpl(menuItem);
            } catch(Error e) {
                // Catch access violation from improper DLL load and pray that
                // it didn't horribly corrupt any memory.  See comments for
                // popupSaveDialogFallback().
                popupSaveDialogFallback(menuItem);
            }
        }

    public:
        ///
        this(FigureWidget widget) {
            super("Plot Window.  Right-click to save plot.");
            this.widget = widget;
            this.add(widget);
            widget.setSizeRequest(
                widget.figure.defaultWindowWidth,
                widget.figure.defaultWindowHeight
            );
            this.resize(widget.getWidth, widget.getHeight);
            this.setSizeRequest(
                widget.figure.minWindowWidth,
                widget.figure.minWindowHeight
            );

            this.addOnButtonPress(&clickEvent);
            this.rightClickMenu = buildRightClickMenu();

            widget.addOnSizeAllocate(&widget.parentSizeChanged);
            widget.showAll();
            widget.queueDraw();
            this.showAll();
        }
    }
}

}
